#!/usr/bin/env python3
# vim: filetype=python ts=2 sw=2 sts=2 et :

"""
Optimizer, written as a data miner.  Break the data up into regions
of 'bad' and 'better'. 'Interesting' things occur at very different
frequencies in 'bad' and 'better'. Find interesting bits. Combine
them. Repeat. Nearly all this processing takes log linear time.

 :-------:                 active learning = explore at better==bad
 | Ba    | Bad <----.      planning        = max(better - bad)
 |    56 |          |      monitor         = max(bad - better)
 :-------:------:   |      tabu            = min(bad + better)
         | B    |   v       
         |    5 | Better
         :------:

(c) Tim Menzies, 2021
MIT License, https://opensource.org/licenses/MIT. The source code
does not need to be public when a distribution of the software is
made. Modifications to the software can be release under any
license. Changes made to the source code may not be documented.
"""

from tricks import arg, args, neg, eg, ok,o
from tricks import re, sys, math, random

IT=args("duo",__doc__, 
    arg("show version", V=False),
    arg("data dir", data="../data/"),
    # -------------------------------------
    arg("walk one test (stop if it crashes)", w=""),
    arg("run one test (continuing of crashes)", t=""),
    arg("run all tests", T=False),
    # -------------------------------------
    arg("misc seed", seed=1),
    # -------------------------------------
    arg("nb kludge for rare attributes", k=1),
    arg("nb kludge for rare classes", m=2),
    # -------------------------------------
    arg("explore buffer size", buffer=512),
    arg("explore era size", wait=20),
    # -------------------------------------
    arg("contrast lives", lives=9),
    arg("contrast population", pop=20),
    arg("contrast attempts per life", attempts=20),
    # -------------------------------------
    arg("some epsilon x", smallx=.35),
    arg("some epsilon y", smally=.2),
    arg("some best", best=.75),
    arg("some want", want=128),
    arg("some want", chop=.5),
    arg("dom samples", samples=64))

# Constatnts
SYM="_"
NUM=":"
MORE=">"
LESS="<"
SKIP="?"
KLASS="!"

#-------------------------------
# Basic utils
def r()    : return random.random()
def r0()   : random.seed(IT.seed)
def col(z) : return None if skip(z) else ([] if num(z) else {})
def num(z) : return LESS in z or MORE in z or NUM in z
def goal(z): return not skip(z) and \
                    LESS in z or MORE in z or KLASS in z
def prep(z): return float if num(z) else str
def skip(z): return SKIP in z
def nums(z): return isinstance(z,list)
def syms(z): return isinstance(z,dict)

mu=   lambda a: sum(a)/ len(a)
sd=   lambda a: (a[int(.9*len(a))] - a[int(.1*len(a))]) /2.56
norm= lambda c,x: max(0, min(1, (x-c[0])/(c[-1]-c[0]+1E-32)))

def csv(file, sep=",", ignore=r'([\n\t\r ]|#.*)'):
  fs=[]
  with open(file) as fp:
    for a in fp:
      a = re.sub(ignore,'',a).split(sep)
      if fs: a  = [(x if x==SKIP else f(x)) 
                   for f, x in zip(fs,a)]
      else:  fs = [prep(x) for x in a]
      yield a

#--------------
# Loading data
def data(src):
  d = o(names=[],rows=[],cols=[], 
        counts={}, also=o(x={},y={},bins={}))
  for zs in src:
    if d.cols:
      for z,c in zip(zs,d.cols): remember(z,c)
      d.rows += [o(x=zs, dom=0, y=None)]
    else:
      d.names = zs
      d.cols  = [col(z) for z in zs]
      for n,z in enumerate(zs):
        if not skip(z):
          what = d.also.y if goal(z) else d.also.x
          what[n] = (-1 if LESS in z else 
                    ( 1 if MORE in z else 0))
  # sort before doing anything else
  [col.sort() for col in d.cols if nums(col)]
  classify(d)
  # must be after classify
  discretize(d)
  for n,bins in d.also.bins.items():
    if nums(bins) and not goal(d.names[n]):
       print(d.names[n],bins)
  d.counts = counts(d)
  return d

def classify(d):
  ys=[]
  for row in d.rows:
    for _ in range(IT.samples):
      row.dom += dom(d, row, random.choice(d.rows))
    ys += [row.dom]
  ys = sorted(ys)
  best = ys[ int(IT.best*len(ys)) ]
  for row in d.rows:
    row.y = row.dom > best

def discretize(d):
  for n,col in enumerate(d.cols):
    d.also.bins[n] = merge(n,div(col),d.rows) if nums(col) else col

def counts(d):
  f,h = {}, {}
  for row in d.rows:
    y = row.y
    h[y] = h.get(y, 0) + 1
    for n,bins in d.also.bins.items():
      if bins:
        x = row.x[n] 
        if x != SKIP:
          x1 = bin(bins,x)
          v = (y, n,x1)
          f[v] = f.get(v,0) + 1
  return o(f=f, h=h)

def remember(x,c): 
  if x != SKIP: 
    if syms(c): c[x] = c.get(x,0)+1
    if nums(c): c += [x]
  return x

def dom(d, i, j):
  val = lambda k,c: norm(d.cols[c],k.x[c])
  n = s1 = s2 = 0
  n = len(d.also.y)
  for col,w in d.also.y.items():
    a,b = val(i, col), val(j, col)
    s1 -= math.e**(w * (a - b) / n)
    s2 -= math.e**(w * (b - a) / n)
  return s1/n < s2/n

#---------
# Discretize
def bin(bins, x):
  if x==SKIP: 
    return x
  elif nums(bins):
    for n, y in enumerate(bins):
      if x <= y: return y
    return math.inf
  else:
    return x

def div(a, smallx = IT.smallx):
  ok = sd(a)*smallx
  n = len(a)**IT.chop
  while n < 4 and n<len(a)/2: n*=1.2
  n = int(n)
  out, hi, lo = [], n, 0 
  while hi < len(a) - n :
    hi += 1
    if hi-lo > n and a[hi] != a[hi+1] and a[hi] - a[lo] > ok:
       out += [a[hi]]
       lo,hi = hi, hi+n
  return out

def merge(n,bins,rows):
  all, ys = {},[]
  for row in rows:
    x = row.x[n]
    if x!=SKIP:
      x    = bin(bins, row.x[n])
      one  = all[x] = all.get(x,[])
      one += [row.dom]
      ys  += [row.dom]
  ok = sd(sorted(ys)) * IT.smally
  all = merge1(ok,sorted(all.items()))
  return [x[0] for x in all]

def merge1(ok, lst):
  j,tmp = 0,[]
  while j < len(lst):
    a, y1 = lst[j]
    if j < len(lst)-1:
      b,y2 = lst[j+1]
      y3 = y1+y2
      if abs(mu(y1) - mu(y2)) < ok:
        tmp += [(b,y3)]
        j   += 2
        continue
    tmp += [(a,y1)]
    j += 1
  return merge1(ok,tmp) if len(tmp) < len(lst) else lst

 
@eg
def aa():
  r0()
  d = data(csv(IT.data+"auto93.csv"))
  #rows = sorted(d.rows,key=lambda z:z.y)
  #print([d.names[c] for c in d.also.y]+['y'])
  #for r in rows[:10]: print([r.x[c] for c in d.also.y]+[r.y])
  #print("#")
  #for r in rows[-10:]: print([r.x[c] for c in d.also.y]+[r.y])
  

  #for i in range(10): print([d.rows[i].cells[x] for x in d.ys.keys()])
  #print("")
  #for i in range(10): print([d.rows[-i].cells[x] for x in d.ys.keys()])
