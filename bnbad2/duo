#!/usr/bin/env python3
# vim: filetype=python ts=2 sw=2 sts=2 et :

"""
Optimizer, written as a data miner.  Break the data up into regions
of 'bad' and 'better'. 'Interesting' things occur at very different
frequencies in 'bad' and 'better'. Find interesting bits. Combine
them. Repeat. Nearly all this processing takes log linear time.

 :-------:                 active learning = explore at better==bad
 | Ba    | Bad <----.      planning        = max(better - bad)
 |    56 |          |      monitor         = max(bad - better)
 :-------:------:   |      tabu            = min(bad + better)
         | B    |   v       
         |    5 | Better
         :------:

(c) Tim Menzies, 2021
MIT License, https://opensource.org/licenses/MIT. The source code
does not need to be public when a distribution of the software is
made. Modifications to the software can be release under any
license. Changes made to the source code may not be documented.
"""

from tricks import arg, args, neg, eg, ok,o
from tricks import re, sys, math, random

IT=args("duo",__doc__, 
    arg("show version", V=False),
    arg("data dir", data="../data/"),
    # -------------------------------------
    arg("walk one test (stop if it crashes)", w=""),
    arg("run one test (continuing of crashes)", t=""),
    arg("run all tests", T=False),
    # -------------------------------------
    arg("misc seed", seed=1),
    # -------------------------------------
    arg("nb kludge for rare attributes", k=1),
    arg("nb kludge for rare classes", m=2),
    # -------------------------------------
    arg("explore buffer size", buffer=512),
    arg("explore era size", wait=20),
    # -------------------------------------
    arg("contrast lives", lives=9),
    arg("contrast population", pop=20),
    arg("contrast attempts per life", attempts=20),
    # -------------------------------------
    arg("some epsilon x", smallx=.35),
    arg("some epsilon y", smally=.2),
    arg("some best", best=.75),
    arg("some want", want=128),
    arg("some want", chop=.5),
    arg("dom samples", samples=64))

# Constatnts
SYM="_"
NUM=":"
MORE=">"
LESS="<"
SKIP="?"
KLASS="!"

#-------------------------------
# Basic utils
def r()    : return random.random()
def r0()   : random.seed(IT.seed)
def col(z) : return None if skip(z) else ([] if num(z) else {})
def num(z) : return LESS in z or MORE in z or NUM in z
def goal(z): return not skip(z) and \
                    LESS in z or MORE in z or KLASS in z
def prep(z): return float if num(z) else str
def skip(z): return SKIP in z
def nums(z): return isinstance(z,list)
def syms(z): return isinstance(z,dict)

mu=   lambda a: sum(a)/ len(a)
sd=   lambda a: (a[int(.9*len(a))] - a[int(.1*len(a))]) /2.56
norm= lambda c,x: max(0, min(1, (x-c[0])/(c[-1]-c[0]+1E-32)))

def csv(file, sep=",", ignore=r'([\n\t\r ]|#.*)'):
  fs=[]
  with open(file) as fp:
    for a in fp:
      a = re.sub(ignore,'',a).split(sep)
      if fs: a  = [(x if x==SKIP else f(x)) 
                   for f, x in zip(fs,a)]
      else:  fs = [prep(x) for x in a]
      yield a

#--------------
# Loading data
def data(src):
  d = o(names=[],rows=[],cols=[], 
        counts={}, some=o(x={},y={},bins={}))
  for zs in src:
    if d.cols:
      for z,c in zip(zs,d.cols): remember(z,c)
      d.rows += [o(x=zs, dom=0, y=None)]
    else:
      d.names = zs
      d.cols  = [col(z) for z in zs]
      for n,z in enumerate(zs):
        if not skip(z):
          what = d.some.y if goal(z) else d.some.x
          what[n] = (-1 if LESS in z else 
                    ( 1 if MORE in z else 0))
  return completeInitialization(d)

def remember(x,c): 
  if x!=SKIP: 
    if syms(c): c[x] = c.get(x,0)+1
    if nums(c): c += [x]

def dom(d, i, j):
  val = lambda k,c: norm(d.cols[c],k.x[c])
  n = s1 = s2 = 0
  n = len(d.some.y)
  for col,w in d.some.y.items():
    a,b = val(i, col), val(j, col)
    s1 -= math.e**(w * (a - b) / n)
    s2 -= math.e**(w * (b - a) / n)
  return s1/n < s2/n

#---------
# Discretize
def bin(bins, x):
  for n, y in enumerate(bins):
    if x <= y: return y
  return math.inf

def div(c, smallx = IT.smallx):
  ok = sd(c)*smallx
  n = len(c)**IT.chop
  while n < 4 and n<len(c)/2: n*=1.2
  n = int(n)
  out, hi, lo = [], n, 0 
  while hi < len(c) - n :
    hi += 1
    if hi-lo > n and c[hi] != c[hi+1] and c[hi] - c[lo] > ok:
       out += [c[hi]]
       lo,hi = hi, hi+n
  return out

def merge(col,bins,rows):
  all, ys = {},[]
  for row in rows:
    x    = bin(bins, row.x[col])
    one  = all[x] = all.get(x,[])
    one += [row.y]
    ys  += [row.y]
  ok = sd(sorted(ys)) * IT.smally
  all = merge1(ok,sorted(all.items()))
  return [x[0] for x in all]

def merge1(ok, lst):
  j,tmp = 0,[]
  while j < len(lst):
    a, y1 = lst[j]
    if j < len(lst)-1:
      b,y2 = lst[j+1]
      y3 = y1+y2
      if abs(mu(y1) - mu(y2)) < ok:
        tmp += [(b,y3)]
        j   += 2
        continue
    tmp += [(a,y1)]
    j += 1
  return merge1(ok,tmp) if len(tmp) < len(lst) else lst

def completeInitialization(d):
  d.cols=[sorted(c) if nums(c) else c for c in d.cols]
  ys=[]
  k = 1/IT.samples
  for row in d.rows:
    for _ in range(IT.samples):
      row.dom += dom(d, row, random.choice(d.rows))
    ys += [row.dom]
  ys = sorted(ys)
  best = ys[ int(IT.best*len(ys)) ]
  for row in d.rows:
    row.y = row.dom > best
  for n,(name,col) in enumerate(zip(d.names,d.cols)):
    if nums(col):
      d.some.bins[n] = merge(n, div(col), d.rows)
  d.counts = counts(d)
  f = d.counts.f
  return d

def counts(d):
  f,h = {}, {}
  for row in d.rows:
    y = row.y
    h[y] = h.get(y, 0) + 1
    for n,col in enumerate(d.cols):
      if col:
        x = row.x[n] 
        if n in d.some.bins:
          x = bin(d.some.bins[n],x)
        v = (y, n,x)
        f[v] = f.get(v,0) + 1
  return o(f=f, h=h)
  
@eg
def aa():
  r0()
  d = data(csv(IT.data+"auto93.csv"))
  #rows = sorted(d.rows,key=lambda z:z.y)
  #print([d.names[c] for c in d.some.y]+['y'])
  #for r in rows[:10]: print([r.x[c] for c in d.some.y]+[r.y])
  #print("#")
  #for r in rows[-10:]: print([r.x[c] for c in d.some.y]+[r.y])
  

  #for i in range(10): print([d.rows[i].cells[x] for x in d.ys.keys()])
  #print("")
  #for i in range(10): print([d.rows[-i].cells[x] for x in d.ys.keys()])
