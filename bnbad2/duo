#!/usr/bin/env python3
# vim: filetype=python ts=2 sw=2 sts=2 et:

"""
Optimizer, written as a data miner.  Break the data up into regions
of 'bad' and 'better'. 'Interesting' things occur at very different
frequencies in 'bad' and 'better'. Find interesting bits. Combine
them. Repeat. Nearly all this processing takes log linear time.

 :-------:                 active learning = explore at better==bad
 | Ba    | Bad <----.      planning        = max(better - bad)
 |    56 |          |      monitor         = max(bad - better)
 :-------:------:   |      tabu            = min(bad + better)
         | B    |   v       
         |    5 | Better
         :------:

(c) Tim Menzies, 2021
MIT License, https://opensource.org/licenses/MIT. The source code
does not need to be public when a distribution of the software is
made. Modifications to the software can be release under any
license. Changes made to the source code may not be documented.
"""

from tricks import arg, args, neg, eg, ok,o
from tricks import re, sys, math, random

IT=args("duo",__doc__, 
    arg("show version", V=False),
    arg("data dir", data="../data/"),
    # -------------------------------------
    arg("walk one test (stop if it crashes)", w=""),
    arg("run one test (continuing of crashes)", t=""),
    arg("run all tests", T=False),
    # -------------------------------------
    arg("misc seed", seed=1),
    # -------------------------------------
    arg("nb kludge for rare attributes", k=1),
    arg("nb kludge for rare classes", m=2),
    # -------------------------------------
    arg("explore buffer size", buffer=512),
    arg("explore era size", wait=20),
    # -------------------------------------
    arg("contrast lives", lives=9),
    arg("contrast population", pop=20),
    arg("contrast attempts per life", attempts=20),
    # -------------------------------------
    arg("some epsilon", cohen=.35),
    arg("some cohen", split=.5),
    arg("some want", want=128),
    arg("some want", best=.75),
    arg("dom samples", samples=128))

SYM="_"
NUM=":"
MORE=">"
LESS="<"
SKIP="?"
KLASS="!"

def r()    : return random.random()
def r0()   : random.seed(IT.seed)
def col(z) : return None if skip(z) else ([] if num(z) else {})
def num(z) : return LESS in z or MORE in z or NUM in z
def prep(z): return float if num(z) else str
def skip(z): return SKIP in z
def nums(z): return isinstance(z,list)
def syms(z): return isinstance(z,dict)

def csv(file, sep=",", ignore=r'([\n\t\r ]|#.*)'):
  fs=[]
  with open(file) as fp:
    for a in fp:
      a = re.sub(ignore,'',a).split(sep)
      if fs: a  = [(x if x==SKIP else f(x)) 
                   for f, x in zip(fs,a)]
      else:  fs = [prep(x) for x in a]
      yield a

def data(src):
  names, cols, rows,w = [],[],[],[]
  for a in src:
    if cols:
      for c,x in zip(cols,a): got(x,c)
      rows += [o(cells=a,dom=0,y=None)]
    else:
      cols  = [col(x) for x in a]
      w     = [(-1 if LESS in x else 
                (1 if MORE in x else 0)) for x in a]
      names = a
  return o(names=names, cols=cols, 
           rows=rows, w=w, xs={},ys={}, bins={})

def got(x,c): 
  if x!=SKIP: 
    if syms(c): c[x] = c.get(x,0)+1
    if nums(c): 
      if len(c) <= IT.want: c += [x]
      elif r() < IT.want / len(c): c[int(r()*len(c))] = x
  
def sd(a)   : 
  lo,hi = .1*len(a), .9*len(a);
  return (a[int(hi)] - a[int(lo)]) /2.56

def bin(bins, x):
  for n, y in enumerate(bins):
    if x <= y: return n,y
  return n+1,math.inf

def bins(c):
  if nums(c): 
    d = sd(c)*IT.cohen
    n = len(c)**IT.split
    while n < 4 and n<len(c)/2: n*=1.2
    n = int(n)
    out, hi, lo = [], n, 0 
    while hi < len(c) - n :
      hi += 1
      if hi-lo > n and c[hi] != c[hi+1] and c[hi]-c[lo] > d:
        out += [c[hi]]
        lo = hi
        hi += n
    return out

def norm(c,x):
  lo,hi = c[0],c[-1]
  return max(0, min(1, (x-lo)/(hi-lo+1E-32)))

# Return true if `i` is better than `j`.
def dom(i, j, data):
  val = lambda r,c: norm(data.cols[c],r.cells[c])
  n = s1 = s2 = 0
  n=len(data.ys)
  for col,w in data.ys.items():
    a,b  = val(i,col), val(j,col)
    s1  -= math.e**(w * (a - b) / n)
    s2  -= math.e**(w * (b - a) / n)
  return s1/n < s2/n

def merge(pos,bins,rows):
  all = {}
  for row in rows:
    x = row.cells[pos]
    if x != SKIP:
      _,x    = bin(bins,x)
      y      = row.y
      one    = all[x] = all.get(x,{})  
      one[y] = one.get(y,0) + 1
  return [x[0] for x in merge1(sorted(all.items()))]

def merge1(lst):
  j,tmp = 0,[]
  while j < len(lst):
    a, d1 = lst[j]
    if j < len(lst)-1:
      b,d2 = lst[j+1]
      if d := simpler(a,b,d1,d2):
        print("<")
        tmp += [(b,d)]
        j   += 2
        continue
    tmp += [(a,d1)]
    j += 1
  return merge1(tmp) if len(tmp) < len(lst) else lst

def simpler(a,b,d1,d2):
  all= lambda z  : sum(z.values())
  ent= lambda z,n: sum(- v/n*math.log2(v/n) for v in z.values())
  d = {}
  for k,v in d1.items(): d[k] = v
  for k,v in d2.items(): d[k] = d.get(k,0) + v
  n1, n2 = all(d1), all(d2)
  n = n1 + n2
  # print("")
  # print(a,b)
  # print(1, n1, d1,  ent(d1,n1))
  # print(2, n2, d2,  ent(d2,n2))
  # print(12, n,  d,   ent(d,n))
  # print(12, ent(d,n) <= (n1*ent(d1,n1) + n2*ent(d2,n2))/n)
  if ent(d,n) <= (n1*ent(d1,n1) + n2*ent(d2,n2))/n:
    return d

def classify(d):
  lst = []
  for x in d.rows:
    for _ in range(IT.samples):
      y = random.choice(d.rows)
      x.dom += dom(x,y,d)
    got(x.dom, lst)
  lst = sorted(lst)
  best = lst[ int(IT.best*len(lst)) ]
  for x in d.rows:
    _,x.y = bin(lst,x.dom)
 
def ready(d):
  d.cols = [(sorted(c) if nums(c) else c) for c in d.cols]
  for pos,w in enumerate(d.w): (d.ys if w else d.xs)[pos] = w
  classify(d) 
  for pos,col in enumerate(d.cols):
    if nums(col):
      lst1 = bins(col)
      lst2 =  merge(pos, lst1, d.rows)
      d.bins[pos] = lst2
      print("\n---", pos,"\n\t",lst1,"\n\t",lst2)
  return d

@eg
def aa():
  r0()
  d=ready(data(csv(IT.data+"auto93.csv")))
  print("ys",d.ys)
  d.rows = sorted(d.rows, 
              key =lambda r:- r.dom)
  #for i in range(10): print([d.rows[i].cells[x] for x in d.ys.keys()])
  #print("")
  #for i in range(10): print([d.rows[-i].cells[x] for x in d.ys.keys()])
