#!/usr/bin/env python3
# vim: filetype=python ts=2 sw=2 sts=2 et:

"""Optimizer, written as a data miner.  Break the data up into regions
of 'bad' and 'better'. 'Interesting' things occur at very different
frequencies in 'bad' and 'better'. Find interesting bits. Combine
them. Repeat. Nearly all this processing takes log linear time.

 :-------:                 active learning = explore at better==bad
 | Ba    | Bad <----.      planning        = max(better - bad)
 |    56 |          |      monitor         = max(bad - better)
 :-------:------:   |      tabu            = min(bad + better)
         | B    |   v       
         |    5 | Better
         :------:

(c) Tim Menzies, 2021
MIT License, https://opensource.org/licenses/MIT. The source code
does not need to be public when a distribution of the software is
made. Modifications to the software can be release under any
license. Changes made to the source code may not be documented.
"""

from tricks import arg, args, neg, eg, ok,o
from tricks import re, sys, math, random

IT=args("duo",__doc__, 
    arg("show version", V=False),
    arg("data dir", data="../data/"),
    # -------------------------------------
    arg("walk one test (stop if it crashes)", w=""),
    arg("run one test (continuing of crashes)", t=""),
    arg("run all tests", T=False),
    # -------------------------------------
    arg("misc seed", seed=1),
    # -------------------------------------
    arg("nb kludge for rare attributes", k=1),
    arg("nb kludge for rare classes", m=2),
    # -------------------------------------
    arg("explore buffer size", buffer=512),
    arg("explore era size", wait=20),
    # -------------------------------------
    arg("contrast only above best ", best=0.0),
    arg("contrast lives", lives=9),
    arg("contrast population", pop=20),
    arg("contrast attempts per life", attempts=20),
    # -------------------------------------
    arg("some epsilon", cohen=.35),
    arg("some cohen", split=.5),
    arg("some want", want=128),
    # -------------------------------------
    arg("table samples", samples=64))

SYM="_"
NUM=":"
MORE=">"
LESS="<"
SKIP="?"
KLASS="!"

def r()     : return random.random()
def r0()    : random.seed(IT.seed)
def col(z)  : return None if skip(z) else ([] if num(z) else {})
def num(z)  : return LESS in z or MORE in z or NUM in z
def prep(z) : return float if num(z) else str
def skip(z) : return SKIP in z
def nums(z): return isinstance(z,list)
def syms(z): return isinstance(z,dict)

def csv(file, sep=",", ignore=r'([\n\t\r ]|#.*)'):
  fs=[]
  with open(file) as fp:
    for a in fp:
      a = re.sub(ignore,'',a).split(sep)
      if fs: a  = [(x if x==SKIP else f(x)) 
                   for f, x in zip(fs,a)]
      else:  fs = [prep(x) for x in a]
      yield a

def data(src):
  names, cols, rows,w = [],[],[],[]
  for a in src:
    if cols:
      for c,x in zip(cols,a): got(x,c)
      rows += [o(cells=a,dom=0,y=None)]
    else:
      cols  = [col(x) for x in a]
      w     = [(-1 if LESS in x else 1) for x in a]
      names = a
  return o(names=names, cols=cols, rows=rows, w=w)

def got(x,c):
  if x!=SKIP: 
    if syms(c): c[x] = c.get(x,0)+1
    if nums(c): 
      if len(c) <= IT.want: c += [x]
      elif r() < IT.want / len(c): c[int(r()*len(c))] = x
  
def sd(a)   : 
  lo,hi = .1*len(a), .9*len(a);
  return (a[int(hi)] - a[int(lo)]) /2.56

def bin(bins, x):
  for n, y in enumerate(bins):
    if x <= y: return n
  return n+1

def bins(c):
  if nums(c): 
    d = sd(c)*IT.cohen
    n = len(c)**IT.split
    while n < 4 and n<len(c)/2: n*=1.2
    n = int(n)
    out, hi, lo = [], n, 0 
    while hi < len(c) - n :
      hi += 1
      if hi-lo > n and c[hi] != c[hi+1] and c[hi]-c[lo] > d:
        out += [hi]
        lo = hi
        hi += n
    return out

def merge(pos,bins,rows):
  all = {}
  for row in rows:
    x = row.cells[pos]
    if x != SKIP:
      x      = bin(bins,x)
      y      = row.y
      one    = all[x] = all.get(x,{})  
      one[y] = one.get(y,0) + 1
  return merge1(sorted(all.items()))

def merge1(lst):
  j,tmp = 0,[]
  while j < len(lst):
    a, d1 = lst[j]
    if j < len(lst)-1:
      b,d2 = lst[j+1]
      if d := simpler(d1,d2):
        a,d1 = b,d
        j += 1
    tmp += [(a,d1)]
    j += 1
  return merge1(tmp) if len(tmp) < len(lst) else lst

def simpler(d1,d2):
  all= lambda z  : sum(z.values)
  ent= lambda z,n: sum(- v/n*math.log2(v/n) for v in z.values)
  #----------------------
  d = {}
  for k,v in d1.items(): d[k] = v
  for k,v in d2.items(): d[k] = d.get(k,0) + v
  n1, n2 = all(d1), all(d2)
  n = n1 + n2
  if ent(d,n) <= (n1*ent(d1,n1) + n2*ent(d2,n2))/n:
    return d

def ready(d):
  d.cols = [(sorted(c) if nums(c) else c) for c in d.cols]
  return d
@eg
def aa():
  r0()
  d=ready(data(csv(IT.data+"auto93.csv")))
  for name,col in zip(d.names,d.cols):
    print(name, bins(col))
