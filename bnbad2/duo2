#!/usr/bin/env python3
# vim: filetype=python ts=2 sw=2 sts=2 et :

"""
Optimizer, written as a data miner.  Break the data up into regions
of 'bad' and 'better'. 'Interesting' things occur at very different
frequencies in 'bad' and 'better'. Find interesting bits. Combine
them. Repeat. Nearly all this processing takes log linear time.

     :-------:                 explore  = better==bad
     | Ba    | Bad <----.      planning = max(better - bad)
     |    56 |          |      monitor  = max(bad - better)
     :-------:------:   |      tabu     = min(bad + better)
             | B    |   v       
             |    5 | Better
             :------:

(c) Tim Menzies, 2021
MIT License, https://opensource.org/licenses/MIT. The source code
does not need to be public when a distribution of the software is
made. Modifications to the software can be release under any
license. Changes made to the source code may not be documented.
"""

from tricks import about,arg, args, neg, eg, run,ok,o,printm
from tricks import re, sys, math, random

options=["duo",__doc__, 
    arg("show version", V=False),
    arg("data dir", data="../data/"),
    arg("misc seed", seed=1),
    arg("char for symbols", sym="_"),
    arg("char for numerics", num=":"),
    arg("char for more", more=">"),
    arg("char for less", less="<"),
    arg("char for skip", skip="?"),
    arg("char for klass", klass="!"),
    arg("nb kludge for rare attributes", k=1),
    arg("nb kludge for rare classes", m=2),
    arg("contrast lives", lives=9),
    arg("contrast population", pop=20),
    arg("contrast attempts per life", staggers=20),
    arg("some epsilon x", smallx=.35),
    arg("some epsilon y", smally=.5),
    arg("some best", best=.80),
    arg("some want", chop=.5),
    arg("dom samples", samples=64)]

the=about(*options)

#-------------------------------
# ## General stuff

# ### Predicates

def nump(z) :   return  the.less in z or the.more in z or the.num in z 
def goalp(z):   return  the.less in z or the.more in z or the.klass in z
def klassp(z):  return  the.klass in z

# ### Structs

def row(cells): return o(cells=cells, score=0, klass=None)
def data():     return o(rows=[], names=[], cols=cols(),counts=tally())
def cols():     return o(all=things(), x=things(), y=things(), 
                         klass=None, w={}, bins={},goals={})
def things():   return o(all={},nums={},syms={})
def tally():    return o(f={},h={},n=0)

# ### Misc

# Reset seed
def r0()   : random.seed(the.seed)  

# Stats from lists (`sd` and `norm` assume sorted data)
def mu(a):     return sum(a)/ len(a)
def sd(a):     return (a[int(.9*len(a))] - a[int(.1*len(a))]) /2.56
def norm(x,a): return max(0, min(1, (x-a[0])/(a[-1]-a[0]+1E-32)))

# Given a list of numerics, report which group holds `x`
def bin(bins, x):
  for n, y in enumerate(bins):
    if x <= y: return y
  return math.inf

# Process a certain group of columns; ignore empty cells
def cells(lst,cols):
  lst = lst if isinstance(lst,list) else lst.cells
  for pos,col in cols.items():
    val = lst[pos]
    if val!=the.skip: yield pos,val,col

# Csv reader. Kill whitespace and comments. Using columns names in
# row1, control what strings get converted into floats.
def csv(file, sep=",", ignore=r'([\n\t\r ]|#.*)'):
  fs=[]
  with open(file) as fp:
    for a in fp:
      a = re.sub(ignore,'',a).split(sep)
      if fs: a  = [(x if x==the.skip else f(x)) for f, x in zip(fs,a)]
      else:  fs = [(float if nump(x) else str) for x in a]
      yield a

#-------------------------------
# ## Ingest
# Creating data tables

def ingest(src):
  data_ =data()
  for lst in src:
    (body if data_.names else head)(data_ ,lst)
  return footer(data_)

# ### ingest/ head
# Initialize `data.cols`

def head(DATA,LST):
  def head1(pos,txt):
    "Add to  (nums or syms) into (all and (x or y))"
    x = [] if nump(txt) else {}
    if klassp(txt): DATA.cols.klass = x
    for z in [DATA.cols.all, 
              DATA.cols.y if goalp(txt) else DATA.cols.x]:
      z.all[pos] = x
      (z.nums if nump(txt) else z.syms)[pos] = x
    "Update goal and goal weights."
    if nump(txt) and goalp(txt):
       DATA.cols.goals[pos] = x
       DATA.cols.w[pos] = (-1 if the.less in txt else 
                          ( 1 if the.more in txt else 0))
  # `head` control
  DATA.cols =  cols()
  DATA.names = LST
  [head1(i,x) for i,x in enumerate(LST) if the.skip not in x]

# ### ingest / head / body
# Update the column summaries, create new rows.

def body(data,lst):
  "Update symbolics"
  for _,x,c in cells(lst, data.cols.all.syms): c[x] = c.get(x,0) + 1
  "Update numerics"
  for _,x,c in cells(lst, data.cols.all.nums): c += [x]
  "Make a new row"
  data.rows += [row(lst)]

# ### ingest / head / footer
# All the stuff to do after reading data

def footer(DATA):
  def classify(): 
    "klass=TRUE if usually domiante others"
    ys=[]
    for row in DATA.rows:
      for _ in range(the.samples):
        row.score += better(row, random.choice(DATA.rows))
      ys += [row.score]
    ys = sorted(ys)
    best = ys[ int(the.best*len(ys)) ]
    for row in DATA.rows:
      row.klass = row.score > best

  def better(i, j):  
    "Is row `i` better than row `j`?"
    n = s1 = s2 = 0
    n = len(DATA.cols.goals)
    for pos,col in DATA.cols.goals.items():
      w   = DATA.cols.w[pos]
      a,b = i.cells[pos], j.cells[pos]
      a,b = norm(a, col), norm(b,col)
      s1 -= math.e**(w * (a - b) / n)
      s2 -= math.e**(w * (b - a) / n)
    return s1/n < s2/n

  def discretize(): 
    "Split numerics   (uses `div` and `merge`, below."
    for pos,name in enumerate(DATA.names):
      if nump(name) and not goalp(name):
        b4=div(DATA.cols.x.nums[pos])
        after= merge(pos,DATA.rows,b4)
        print(name, "\n\t",b4," ==> \n\t",after)
        DATA.cols.bins[pos] = after
  
  def counts(): 
    "Summaries DATA via range frequency counts"
    t= DATA.counts
    for row in DATA.rows:
      t.n += 1
      klass = row.klass
      t.h[klass] = t.h.get(klass, 0) + 1
      for pos,x,_ in cells(row, DATA.cols.x.syms):
        v= (klass, pos, x)
        t.f[v] = t.f.get(v,0) + 1
      for pos,x,_ in cells(row, DATA.cols.x.nums):
        x=  bin(DATA.cols.bins[pos],x)
        v= (klass, pos, x)
        t.f[v] = t.f.get(v,0) + 1
  # `footer` control
  [col.sort() for col in DATA.cols.all.nums.values()]
  classify()   # count who dominates who
  discretize() # must be after classify, supervised splits
  counts()     # generate frequency counts
  return DATA


#------
# ## Discretization

# ### div
# Split sorted list of numbers into bins

def div(lst):
  ok = sd(lst)*the.smallx
  n = len(lst)**the.chop
  while n < 4 and n<len(lst)/2: n*=1.2
  n = int(n)
  out, hi, lo = [], n, 0 
  while hi < len(lst) - n :
    hi += 1
    if (hi-lo > n                    # enough left after this split
        and lst[hi] != lst[hi+1]     # we can split here
        and lst[hi] - lst[lo] > ok): # split is big enough
       out += [lst[hi]]  # collect the split point
       lo,hi = hi, hi+n  # jump to the next split
  return out

# ### merge

def merge(pos, rows, bins):
  def shrink(lst,ok):
    "Combine ranges that make little change to the score."
    j,tmp = 0,[]
    while j < len(lst):
      a, y1 = lst[j]
      if j < len(lst)-1:
        b,y2 = lst[j+1]
        if abs(mu(y2) - mu(y1)) < ok: # too little different
          tmp += [(b,y1+y2)] # extend slit to `b`
          j   += 2           # jump to next pair
          continue
      tmp += [(a,y1)]
      j += 1
    return shrink(tmp,ok) if len(tmp) < len(lst) else lst

  def grow(pos,rows,bins):
    "Collect the data needed for `shrink`"
    all, ys = {},[]
    for row in rows:
      x = row.cells[pos]
      if x != the.skip:
        x    = bin(bins, x)
        one  = all[x] = all.get(x,[])
        one += [row.score]
        ys  += [row.score]
    return sorted(all.items()), sd(sorted(ys))*the.smally
  # `merge` control
  return [x[0] for x in shrink(*grow(pos,rows,bins))]

#------
# ## Contrast set learning

def contrast(rules0, COUNTS, HERE, THERE):
  def loop(rules,lives):
    print(".",end="")
    sum, rules = prune(rules)
    if lives < 0 or len(rules) < 2: 
       print("!")
       return rules
    more=[]
    for _ in range(the.staggers):
      a = pick(rules,sum)
      b = pick(rules,sum)
      if c := better(a,b):
        more += [c]
    return loop(rules+more, 
                lives - 1 if more else 0)

  def value(rule):
    b = like(rule, HERE,  2)
    r = like(rule, THERE, 2)
    return (b**2/(b+r)) if b>r+0.01 else 0

  def like(rule,h,hs=None):
    hs = hs if hs else len(COUNTS.h)
    like = prior = (COUNTS.h[h] + the.k) / (COUNTS.n + the.k * hs)
    like = math.log(like)
    for col,values in rule.items():
      f = sum(COUNTS.f.get((h, col, v), 0) for v in values)
      inc = (f + the.m * prior) / (COUNTS.h[h] + the.m)
      like += math.log(inc)
    return math.e**like

  def better(rule1, rule2):
    val1, rule1 = rule1
    val2, rule2 = rule2
    rule3 = dict()
    for k,vs in rule1.items():
      rule3[k] = rule3.get(k,set()) | vs
    for k,vs in rule2.items():
      rule3[k] = rule3.get(k,set()) | vs
    val3 = value(rule3)
    if val3 > val1+0.025 and val3 > val1*0.025: return (val3,rule3)

  def prune(old):
    tmp = [(s,r) for s,r in 
           sorted(old, key=lambda z: -1 * z[0])[:the.pop]
           if s > 0]
    b4 = tmp[0]
    out = [b4]
    sum = b4[0] + 1E-32
    for now in tmp[1:]:
      if now != b4:
        out += [now]
        sum += now[0]
      b4 = now
    return sum,out

  def pick(rules, sum):
    r = random.random()
    for rule in rules:
      r -= rule[0] / sum
      if r <= 0: return rule
    return rule
  # `contrast` control
  return loop([(value(r),r) for r in rules0], the.lives)
 
def learn(counts, here=True):
  out, all = {}, list(set([(c,x) for (_,c,x) in counts.f]))
  for there in counts.h:
    if there != here:
      out[there]= contrast([{c:set([x])} for c,x in all],
                           counts, here,there)
  return out

#-------------------------------------
# tests
#@eg
def _csv():
  all=[row for row in csv(the.data+"weather.csv")]
  ok(len(all)==15,"csv reads?")
  ok(len(all[-1])==5,"rows read?")
  ok(type(all[-1][1])==float, "floats read?")
  ok(type(all[-1][0])==str, "strings read?")

#@eg
def aa():
  r0()
  d=ingest(csv(the.data+"auto93.csv"))
  rows = sorted(d.rows,key=lambda z:z.score)
  printm([['score']+ d.names]+[
          [r.score]+ r.cells for r in rows[:5]]+[
          [r.score]+ r.cells for r in rows[-5:]])
  #print(d.cols)
  #d = datacsv(csv(the.data+"auto93.csv"))
  #rows = sorted(d.rows,key=lambda z:z.y)
  #print([d.names[c] for c in d.also.y]+['y'])
  #for r in rows[:10]: print([r.x[c] for c in d.also.y]+[r.y])
  #print("#")
  #for r in rows[-10:]: print([r.x[c] for c in d.also.y]+[r.y])
  #for i in range(10): print([d.rows[i].cells[x] for x in d.ys.keys()])
  #print("")
  #for i in range(10): print([d.rows[-i].cells[x] for x in d.ys.keys()])

def _contrast():
  r0()
  d=ingest(csv(the.data+"auto93.csv"))
  return learn(d.counts)

if __name__ == "__main__":
  the=args(*options)
  for k,vs in _contrast().items():
    print(k)
    for v in vs: print("\t",v) 
