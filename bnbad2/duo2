#!/usr/bin/env python3
# vim: filetype=python ts=2 sw=2 sts=2 et :

"""
Optimizer, written as a data miner.  Break the data up into regions
of 'bad' and 'better'. 'Interesting' things occur at very different
frequencies in 'bad' and 'better'. Find interesting bits. Combine
them. Repeat. Nearly all this processing takes log linear time.

 :-------:                 active learning = explore at better==bad
 | Ba    | Bad <----.      planning        = max(better - bad)
 |    56 |          |      monitor         = max(bad - better)
 :-------:------:   |      tabu            = min(bad + better)
         | B    |   v       
         |    5 | Better
         :------:

(c) Tim Menzies, 2021
MIT License, https://opensource.org/licenses/MIT. The source code
does not need to be public when a distribution of the software is
made. Modifications to the software can be release under any
license. Changes made to the source code may not be documented.
"""

from tricks import arg, args, neg, eg, run,ok,o,printm
from tricks import re, sys, math, random

IT=args("duo",__doc__, 
    arg("show version", V=False),
    arg("data dir", data="../data/"),
    # -------------------------------------
    #arg("walk one test (stop if it crashes)", w=""),
    #arg("run one test (continuing of crashes)", t=""),
    #arg("run all tests", T=False),
    # -------------------------------------
    arg("misc seed", seed=1),
    # -------------------------------------
    arg("nb kludge for rare attributes", k=1),
    arg("nb kludge for rare classes", m=2),
    # -------------------------------------
    #arg("explore buffer size", buffer=512),
    #arg("explore era size", wait=20),
    # -------------------------------------
    arg("contrast lives", lives=9),
    arg("contrast population", pop=20),
    arg("contrast attempts per life", staggers=20),
    # -------------------------------------
    arg("some epsilon x", smallx=.35),
    arg("some epsilon y", smally=.5),
    arg("some best", best=.80),
    #arg("some want", want=128),
    arg("some want", chop=.5),
    arg("dom samples", samples=64))

#-------------------------------
# Constants
SYM="_"
NUM=":"
MORE=">"
LESS="<"
SKIP="?"
KLASS="!"

#-------------------------------
# Structs
def nump(z) :   return  LESS in z or MORE in z or NUM in z 
def goalp(z):   return  LESS in z or MORE in z or KLASS in z
def klassp(z):  return  KLASS in z

def row(cells): return o(cells=cells, score=0, klass=None)
def data():     return o(rows=[], names=[], cols=cols(),counts=tally())
def cols():     return o(all=things(), x=things(), y=things(), 
                         klass=None, w={}, bins={},goals={})
def things():   return o(all={},nums={},syms={})
def tally():    return o(f={},h={},n=0)

#-------------------------------
#  misc 
def r0()   : random.seed(IT.seed)

def cells(lst,cols):
  lst = lst if isinstance(lst,list) else lst.cells
  for pos,col in cols.items():
    val = lst[pos]
    if val!=SKIP: yield pos,val,col

def csv(file, sep=",", ignore=r'([\n\t\r ]|#.*)'):
  fs=[]
  with open(file) as fp:
    for a in fp:
      a = re.sub(ignore,'',a).split(sep)
      if fs: a  = [(x if x==SKIP else f(x)) for f, x in zip(fs,a)]
      else:  fs = [(float if nump(x) else str) for x in a]
      yield a

#-------------------------------
#routines for sorted lists
# Reading data
def ingest(src):
  d=data()
  for lst in src:
    (body if d.names else head)(d,lst)
  footer(d)
  return d

#-------------------------------
# Creating data headers and cols
def head(d,lst):
  def head1(pos,txt):
    # 1. Add to  (nums or syms) into (all and (x or y))
    x = [] if nump(txt) else {}
    if klassp(txt): d.cols.klass = x
    for z in [d.cols.all, 
              d.cols.y if goalp(txt) else d.cols.x]:
      z.all[pos] = x
      (z.nums if nump(txt) else z.syms)[pos] = x
    # 2. Update goal and goal weights
    if nump(txt) and goalp(txt):
       d.cols.goals[pos] = x
       d.cols.w[pos] = (-1 if LESS in txt else 
                       ( 1 if MORE in txt else 0))
  #--------------------- 
  d.cols =  cols()
  d.names = lst
  [head1(i,x) for i,x in enumerate(lst) if SKIP not in x]

#-------------------------------
# ingesting data rows
def body(d,lst):
  for _,x,c in cells(lst,d.cols.all.syms): c[x] = c.get(x,0) + 1
  for _,x,c in cells(lst,d.cols.all.nums): c += [x]
  d.rows += [row(lst)]

#-------------------------------
# all the stuff to do after reading data
def footer(d):
  def classify():
    ys=[]
    for row in d.rows:
      for _ in range(IT.samples):
        row.score += better(row, random.choice(d.rows))
      ys += [row.score]
    ys = sorted(ys)
    best = ys[ int(IT.best*len(ys)) ]
    for row in d.rows:
      row.klass = row.score > best
  
  # Is row `i` better than row `j`?
  def better(i, j):
    norm=lambda x,a:max(0, min(1, (x-a[0])/(a[-1]-a[0]+1E-32)))
    n = s1 = s2 = 0
    n = len(d.cols.goals)
    for pos,col in d.cols.goals.items():
      w   = d.cols.w[pos]
      a,b = i.cells[pos], j.cells[pos]
      a,b = norm(a, col), norm(b,col)
      s1 -= math.e**(w * (a - b) / n)
      s2 -= math.e**(w * (b - a) / n)
    return s1/n < s2/n
  
  # Split the numeric `x` columns  (uses `div` and `merge`, below.
  def discretize():
    for pos,name in enumerate(d.names):
      if nump(name) and not goalp(name):
        b4=div(d.cols.x.nums[pos])
        after= merge(pos,d.rows,b4)
        print(name, "\n\t",b4," ==> \n\t",after)
        d.cols.bins[pos] = after
  
  # Collect frequency counts of discretized  columns in different classes
  def counts():
    t= d.counts
    for row in d.rows:
      t.n += 1
      klass = row.klass
      t.h[klass] = t.h.get(klass, 0) + 1
      for pos,x,_ in cells(row, d.cols.x.syms):
        v= (klass, pos, x)
        t.f[v] = t.f.get(v,0) + 1
      for pos,x,_ in cells(row, d.cols.x.nums):
        x=  bin(d.cols.bins[pos],x)
        v= (klass, pos, x)
        t.f[v] = t.f.get(v,0) + 1

  [col.sort() for col in d.cols.all.nums.values()]
  classify()   # count who dominates who
  discretize() # must be after classify, supervised splits
  counts()     # generate frequency counts

#---------
# Discretization

# Given a list of numerics, report which group holds `x`
def bin(bins, x):
  for n, y in enumerate(bins):
    if x <= y: return y
  return math.inf

# Split sorted list of numbers into bins
def sd(a):   return (a[int(.9*len(a))] - a[int(.1*len(a))]) /2.56

def div(lst, smallx = IT.smallx):
  ok = sd(lst)*smallx
  n = len(lst)**IT.chop
  while n < 4 and n<len(lst)/2: n*=1.2
  n = int(n)
  out, hi, lo = [], n, 0 
  while hi < len(lst) - n :
    hi += 1
    if (hi-lo > n                    # enough left after this split
        and lst[hi] != lst[hi+1]     # we can split here
        and lst[hi] - lst[lo] > ok): # split is big enough
       out += [lst[hi]]  # collect the split point
       lo,hi = hi, hi+n  # jump to the next split
  return out

def merge(pos,rows,bins):
  def shrink(lst):
    mu =lambda a: sum(a)/ len(a)
    j,tmp = 0,[]
    while j < len(lst):
      a, y1 = lst[j]
      if j < len(lst)-1:
        b,y2 = lst[j+1]
        if abs(mu(y2) - mu(y1)) < ok: # too little different
          tmp += [(b,y1+y2)] # extend slit to `b`
          j   += 2           # jump to next pair
          continue
      tmp += [(a,y1)]
      j += 1
    return shrink(tmp) if len(tmp) < len(lst) else lst

  def grow():
    all, ys = {},[]
    for row in rows:
      x = row.cells[pos]
      if x!=SKIP:
        x    = bin(bins, x)
        one  = all[x] = all.get(x,[])
        one += [row.score]
        ys  += [row.score]
    return sorted(all.items()), sd(sorted(ys))*IT.smally
  #-------------------------
  all, ok = grow()
  return [x[0] for x in shrink(all)]

#-------------------------------------
# Contrast
def contrast(tally,best=True):
  def like(dct,h,hs=None):
    hs = hs if hs else len(tally.h)
    like = prior = (t.h[h] + IT.k) / (tally.n + IT.k * hs)
    like = math.log(like)
    for col,values in dct.items():
      f = sum(t.f.get((h, col, v), 0) for v in values)
      inc = (f + IT.m * prior) / (i.h[h] + IT.m)
      like += math.log(inc)
    return math.e**like

  def score(rule,best,rest):
    b = like(score,best,2)
    r = like(score,rest,2)
    return b**2/(b+r) if b>r+0.01 else 0

  def prune(rules):
    tmp = sorted(rules, key=lambda z: -1 * z[0])[:IT.pop]
    b4 = tmp[0]
    out = [b4]
    total = b4[0] + 1E-32
    for now in tmp[1:]:
      if now != b4:
        out += [now]
        total += now[0]
      b4 = now
    return total,out

  def learn(rules,best,rest,lives):
    print(".",end="")
    total, rules = prune(rules)
    if lives < 0 or len(rules) < 2: return rules
    more=[]
    for _ in range(IT.staggers):
      if c := better(one(rules,total), one(rules,total),
                     best,rest):
        more += [c]
    if more:
      return learn(rules + more,best,rest,lives-1)
    else:
      print("!")
      return rules

  def one(rules, total):
    r = random.random()
    for rule in rules:
      r -= rule[0] / total
      if r <= 0: return rule
    return rule

  def better(r1,r2,best,rest):
    r3=dict()
    for k,v in r1[1].items(): r3[k]=v
    for k,v in r2[1].items(): r3.get(k,set()) | v
    s3= score(r3,best,rest)
    if s3> r1[0] and s3 > r2[0]: return (s3,r3)
  #-----------------
  all={}
  pairs = set([(pos,x) for _,pos,x in tally.h])
  for rest in tally.h:
    if rest != best:
      rules = []
      for pos,x in pairs:
        rule= dict(pos=set(x))
        s   = score(rule,rest)
        rules += [(s,rule)]
      all[rest] = learn(rules,best,rest,IT.lives)
  return all


#-------------------------------------
# tests
@eg
def _csv():
  all=[row for row in csv(IT.data+"weather.csv")]
  ok(len(all)==15,"csv reads?")
  ok(len(all[-1])==5,"rows read?")
  ok(type(all[-1][1])==float, "floats read?")
  ok(type(all[-1][0])==str, "strings read?")

@run
def aa():
  r0()
  d=ingest(csv(IT.data+"auto93.csv"))
  rows = sorted(d.rows,key=lambda z:z.score)
  printm([['score']+ d.names]+[
          [r.score]+ r.cells for r in rows[:5]]+[
          [r.score]+ r.cells for r in rows[-5:]])
  #print(d.cols)
  #d = datacsv(csv(IT.data+"auto93.csv"))
  #rows = sorted(d.rows,key=lambda z:z.y)
  #print([d.names[c] for c in d.also.y]+['y'])
  #for r in rows[:10]: print([r.x[c] for c in d.also.y]+[r.y])
  #print("#")
  #for r in rows[-10:]: print([r.x[c] for c in d.also.y]+[r.y])
  #for i in range(10): print([d.rows[i].cells[x] for x in d.ys.keys()])
  #print("")
  #for i in range(10): print([d.rows[-i].cells[x] for x in d.ys.keys()])

